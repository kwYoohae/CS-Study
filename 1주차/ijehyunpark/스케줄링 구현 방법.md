### 비선점 스케줄링
 - 프로세스가 종료될 떄 까지 CPU의 자원할당을 보장합니다.
### 선점 스케줄링
 - 현재 실행중인 프로세스로부터 CPU를 빼앗아 다른 프로세스에게 할당할 수 있습니다.
 - 우선 순위 기반 스케줄링 혹은 라운드 로빈 스케줄링에서 사용할 수 있습니다.


## 스케줄링 기법
- FIFO
  - 먼저 온 프로세스를 우선하여 실행
  - convoy 효과 발생: 긴 실행시간을 가지는 프로세스에 의해 다른 프로세스의 응답시간이 크게 밀리는 현상
- SJF(Shortest Job First)
  - 대기중인 프로세스 중에서 짧은 실행시간을 가지는 프로세스를 우선하여 실행
  - 여전히 convoy 효과는 발생한다.
- SRT(Shortest Remaining-Time Next)
  - 가장 짧은 실행시간을 가지는 프로세스의 CPU 실행을 보장한다.
  - convoy 효과는 해결하였지만 기아 현상이 발생한다.
  - 기아 현상: 낮은 우선순위를 가진 프로세스가 반영구적으로 실행되지 않는 현상
- RR (Round Robin)
  - 프로세스를 일정 시간만큼 순서대로 실행한다.
  - convoy, 기아 현상은 해결하였지만 context switch 비용이 발생한다.
  - time slice를 낮게 잡을 수록 비용이 커지며 높게 잡을 수록 프로세스의 응답 속도가 느려진다.
- MLFQ (Multi-Level Feedback Queue)
  - 여러 개의 큐를 사용하여 우선순위 스케줄링을 구현하였다.
  - 각 큐벌로 다른 우선순위를 사용하여 스케줄링을 진행한다.
  - 같은 큐 내에서는 RR로 동작한다.
  - 우선 순위 변경 정책: 모든 time slice를 사용한 프로세스의 우선순위를 낮춘다. 이를 통해 긴 사용 시간을 요구하는 프로세스의 긴 CPU 점거를 방지한다.
  - 우선 순위 부스팅 정책: 일정 시간마다 모든 프로세스의 우선순위를 재조정하여 긴 프로세스가 낮은 우선순위 큐에서 발생하는 기아 현상을 방지한다.
  - 더 나은 계산 정책: 사용한 time slice를 저장하여 다름 할당에 적용하는 것으로 의도적으로 time slice를 중간에 포기하여 높은 우선순위를 유지하는 프로세스를 방지한다.

### 티켓 매커니즘
- TODO

### CFS
- TODO

### 멀티 프로세서 스케줄링
- 공정성: 각 프로세스가 공정하게 CPU 시간을 얻을 수 있도록 보장해야 한다.
- 효율성: CPU 자원을 효율적으로 사용하여 작업을 완료하고 응답 시간을 최소화해야 한다.
- 처리량: 단위 시간당 완료된 프로세스를 최대화 해야 한다.
- 각 CPU는 하던 작업을 다시 할당 받아 수행하는 것이 좋다. CPU의 캐시에는 이전에 하던 작업의 값들이 저장되어 있기 때문이다. 이를 캐시 선호도라고 한다.
- Single-Queue Scheduling (단일 대기열 스케줄링)
  - 구현이 단순하고 효율적이다.
  - 캐시 일관성 문제에 비교적 자유롭다.
  - 로드 밸런싱이 간단하다.
  - 우선순위를 구현하기 힘들다.
  - 확장성이 부족하다. 스케줄러가 여러 CPU에서 잘 작동하는지 확인하기 위해 추가적인 Lock 기법이 필요하다.
  - 캐시 선호도를 사용하기 힘들다.
- 멀티 큐 스케줄링
  - 각 큐에 다양한 정책을 사용할 수 있다.
  - 로드 밸런스 문제가 발생한다. 한 큐에 작업이 과하게 할당될 수 있다.

### 작업 훔치기
- 여유로운 프로세서가 다른 프로세서의 작업을 훔쳐간다.



