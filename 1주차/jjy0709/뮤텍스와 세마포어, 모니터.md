참고 자료
 - https://about-myeong.tistory.com/34
 - https://dar0m.tistory.com/234
 - https://wookkingkim.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EB%AE%A4%ED%85%8D%EC%8A%A4-%EB%AA%A8%EB%8B%88%ED%84%B0-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4-%EC%B0%A8%EC%9D%B4%EC%A0%90
---
**운영체제의 동기화 기법**

**동기화**
- 시스템의 자원은 한정적 -> 여러 스레드가 동시에 접근해서 사용하는 경우 문제 발생 가능
- 스레드들에게 하나의 자원에 대한 처리 권한을 주거나 순서를 조정해주는 것

**임계영역**
- 둘 이상의 스레드가 동일한 자원을 동시에 접근하는 경우가 발생하는 코드 영역
- 접근 순서에 따라 실행 결과가 달라지는 구역

**상호배제**
- 한 프로세스가 임계 영역 코드를 수행하고 있으면 다른 프로세스들은 그 코드를 수행할 수 없다는 조건
- 임계 영역을 보호 / 둘 이상의 스레드가 공유 자원에 대해 동시에 읽거나 쓰는 것을 방비
- 상호배제 기법에는 뮤텍스, 세마포어, 모니터, 메시지 전달 등이 있음

### 뮤텍스
- 0 또는 1의 값을 가지는 이진 세마포어와 유사
- 임계 영역을 가진 스레드들이 동시에 실행되지 않도록 하는 기술
- Locking 과 Unlocking 사용
- 알고리즘
  - 데커 알고리즘: flag & turn 변수를 통해 임계 구역에 들어갈 프로세스/스레드를 결정
    - flag: 어떤 프로세스가 임계 영역에 진입할 것인지
    - turn: 어떤 프로세스가 임계 영역에 들어갈 차레인지
  - 피터슨 알고리즘: 데커와 유사, 상대방 프로세스/스레드에 진입 기회를 양보하느 것에 차이
  - 제과점 알고리즘: 여러 프로세스/스레드에 대한 처리가 가능한 알고리즘, 가장 작은 수의 번호표를 가지고 있는 프로세스가 임계 영역에 진입

### 세마포어
- 카운터 값: 프로세스 간 시그널을 주고 받기 위해 사용되는 정수 값, 리소스의 상태를 나타냄 -> 접근할 수 있는 프로세스의 최대 허용치 
- 다음 세가지 **원자적** 연산만을 지원
  - initialize: 초기화(카운터 값을 음이 아닌 정수값으로 초기화)
  - decrement: 카운터 값을 1 감소, 값에 따라 프로세스 블록
  - increment: 카운터 값을 1 증가, 값에 따라 블록되었던 프로세스를 깨움. -> 카운팅/범용 세마포어라 함
- 카운터 값에 따라 프로세스는 즉시 자원을 사용하거나 일정 시간을 기다려야 한다.
- wait() & signal()
  - wait: 임계 영역에 들어갈 수 있는지 확인, 먼저 실행되어야 하는 프로세스의 실행 여부 확인
  - 조건 만족 시 임계 영역 진입
  - signal: 임계 영역 빠져나왔음을 알림
- 이진 세마포어: 0 또는 1의 카운터 값을 가지는 세마포어

### 뮤텍스와 세마포어의 차이
1. 세마포어는 뮤텍스가 될 수 있지만 뮤텍스는 세마포어가 될 수 없다.
2. 세마포어는 소유 불가능(자원의 상태를 나타내는 일종의 '변수'), 뮤텍스는 소유 가능 -> 소유주가 책임
3. 뮤텍스는 소유 스레드 만이 해제 가능, 세마포어의 경우 소유하지 않고 있는 스레드도 해제 가능
4. 세마포어: 시스템 범위에 걸쳐 있음, 파일 형태로 존재 / 뮤텍스: 프로세스 범위, 프로그램 종료 시 자동 삭제
5. ** 세마포어: 동기화 대상이 여러개, 뮤텍스: 동기화 대상이 하나
* 제가 이해하기 편했던 예시는 뮤텍스는 화장실 칸이 하나인 화장실 키를 가지는 화장실이라고 생각하고 세마포어는 칸이 여러개인 화장실로 비유했던 예시입니다. 뮤텍스의
경우 화장실이 사용중이라면 사용자가 나와서 화장실 키를 반납해야 다음 사람이 사용할 수 있고, 세마포어의 경우 위에 비어있는 화장실 칸 개수를 표시해주어 비어있는 화장실
칸이 있다면 바로 사용가능하고 그렇지 않다면 기다려야 합니다. 이 예시를 기억하면 좀 더 잘 이해할 수 있지 않을까..ㅎㅎ

### 모니터
- Lock(Mutex)와 Condition Variables(Queue)를 가지고 있는 동기화 메커니즘
- 자바의 동기화 기법, 모든 객체는 wait(), notifyAll(), notify() 메소드를 가지고 있음 -> Condition Variable의 역할
- 두 개의 Queue가 존재, 각각 배타동기와 조건동기의 역할
  - 배타동기: 하나의 스레드만 공유 자원에 접근할 수 있게 하는 작용
  - 조건동기: 진입 스레드가 블록되면서 새 스레드가 진입가능하게 하는 공간 -> 새 스레드는 조건동기로 블록된 스레드를 깨울 수 있고, 깨워진 스레드는 현재 스레드가 나가면 재진입 가능
- 배타 동기 선언: synchronized 키워드
- wait() 함수 실행 시 진입한 스레드를 조건 동기 queue에 블록, notify() 실행 시 블록된 함수를 깨움

### 모니터와 뮤텍스의 차이
- 뮤텍스: 다른 프로세스간 동기화에 사용
- 모니터: 하나의 프로세스 내에서 `스레드 간의 동기화`, 프레임워크나 라이브러리 자체에서 제공, Java에서 사용하는 동기화 기법

### 모니터와 세마포어의 차이
세마포어
  - 어셈블리 언어에 적합한 도구
  - 프로그래머가 상호 배제나 정렬의 목적으로 사용할 때 매번 Counter 변수 값을 지정해줘야 하는 등 사용 방식이 번거로움
모니터
  - 고수준 언어의 도구, Java에서는 기본으로 제공하지만 C언어에서는 사용 불가능
  - 기능 캡슐화 -> synchronized, wait(), notify() 등의 키워드를 이용하여 편하게 동기화 가능

