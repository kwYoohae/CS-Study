## 흐름제어 
- 만약, 송신측이 데이터를 수신측이 처리를 못하면 늦어지게된다 (데이터의 양)
    - 만약, 늦어지면 패킷이 손실 될 수도 있다
    - 이를 해결하기 위해 흐름제어를 사용해서 송신측과 수신측의 네트워크 데이터 처리 속도차이를 해결한다
- TCP에서는 흐름제어에는 여러가지 방식이 있다 
### Stop And Wait
- TCP는 전송을 할 떄, 매번 전송한 패킷에 대해 ACK응답을 받아야만 그 다음 패킷을 전송하는 흐름제어 해결방법입니다
### Sliding Window 
- Stop And Wait와 다르게 ACK이 오기전에 패킷을 전송할 수 있는 방법이다. 
- 윈도우 사이즈를 우선적으로 정하고 난 뒤에 ACK이 오기 전까지 데이터를 계속해서 보낸다
    - 도착한 (수신측에서 보낸 ACK)에는 TCP 헤더에 window size를 담아서 보냅니다 
    - 도착한 ACK을 온다면 윈도우를 옆으로 옮겨서 다시 다음 패킷을 전송한다
    - 이는 데이터를 다 받을 때 까지 이 과정을 계속 반복을 한다
<img width="817" alt="image" src="https://github.com/kwYoohae/CS-Study/assets/74089271/8eb8137c-f122-4108-87fa-b13ee7a7c530">


## 혼잡제어
- 혼잡 제어는 네트워크 내에서 발생하는 혼잡 현상을 관리하고 제어하여 패킷 손실 및 전송 지연을 최소화 하려는 것입니다
    - 라우터가 데이터를 처리하는 속도보다 많은 양의 데이터가 들어온다면, 계쏙해서 데이터를 유실한것으로 생각하고 데이터를 보내 네트워크가 혼잡해집니다. 
    - 우리는 혼잡제어 기술을 통해, 이러한 송신자의 데이터 전송속도를 조절합니다. 
### Cogestion Window
- window의 크기를 조절하면서, 우리는 이런 방식을 해결할 수 있습니다. 
- 우선 Additive Increase로 패킷을 보냈는데 문제 없이 도착을한다면 window의 크기를 1씩 늘립니다
    - 이러다 만약, 전송에 실패하게 된다면 Multiplicative Decrease를 통해서 Window의 크기를 **절반**으로 줄입니다. 
- 이런방식이 아닌 SLow Start나 Fast Retransmit 방식도 존재합니다 